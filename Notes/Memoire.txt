Content-Type: text/x-zim-wiki
Wiki-Format: zim 0.6
Creation-Date: 2023-07-31T08:50:29+01:00

====== Memoire ======
Créée le Monday 31 July 2023





































CHAPITRE II : CONTEXTE ET 

Dans ce chapitre qui constitue la seconde section de la première partie, notre objectif est de situer notre projet au sein d'un cadre spécifique. En procédant ainsi, nous pourrons saisir plus clairement la condition actuelle de l'entreprise, ce qui facilitera l'identification de la problématique. Ainsi éclairés, nous serons en mesure de définir nos buts et d'opter pour une méthodologie adéquate pour la mise en œuvre de notre projet.


I. CONTEXTE


II. PROBLÉMATIQUE





	DEUXIEME PARTIE : ETUDE CONCEPTUELLE
Dans cette partie, nous definirons queleques termes techniques et nous présenterons l'entreprise éditrice de l'outil utilisé
								
	

__PARTIE II : ÉTUDE CONCEPTUELLE__

Dans cette partie, nous présenterons les outils utilisés et definirons quelques termes techniques 



__CHAPITRE III : Présentation des outils du projet__




Les outils qui seront utilisés pour la mise en place du projet m’ont été judicieusement suggérés. Ces outils sont : Rocky Linux, Java,SSH et Firewall-CMD, Rundeck.

__I- Rocky Linux__

Un système d'exploitation est un ensemble de programmes qui gère les ressources disponibles d'un ordinateur .



	1-Historique (https://rockylinux.org/fr/about)
	
Le 8 décembre 2020, Red Hat a annoncé qu'ils cesseraient le développement de CentOS, qui a été une version en aval, prête pour la production, de Red Hat Enterprise Linux, en faveur d'une nouvelle variante de développement, en amont, plus récent de ce système d'exploitation, connu sous le nom de "CentOS Stream". En réponse, le fondateur original de CentOS, Gregory Kurtzer, a annoncé via un commentaire sur le site web de CentOS qu'il allait à nouveau lancer un projet pour atteindre les objectifs originaux de CentOS. Le nom du projet a été choisi en hommage au cofondateur de CentOS, Rocky McGaugh. Le 12 décembre, le dépôt de code de Rocky Linux était devenu le dépôt le plus tendance sur GitHub.



	1 – Le systeme d’exploitation Rocky Linux 
	
		Rocky Linux est une distribution Linux développée par Rocky Enterprise Software
	Foundation. Elle est destinée à être une version en aval, complète et compatible binairement,
	utilisant le code source du système d'exploitation Red Hat Enterprise Linux (RHEL). L'objectif
	du projet est de fournir un système d'exploitation d'entreprise de qualité production, soutenu par
	la communauté. Rocky Linux, tout comme Red Hat Entreprise Linux et SUSE Linux
	Entreprise, est devenu populaire pour l'utilisation des systèmes d'exploitation d'entreprise. La
	première version release candidate de Rocky Linux a été publiée le 30 avril 2021, et sa
	première version de disponibilité générale a été publiée le 21 juin 2021. Rocky Linux 8 sera
	pris en charge jusqu'en mai 2029.
	
	
	2. Avantages et inconvénients
		a) __Avantages__
	- Au niveau du coût
Le système d'exploitation Linux est livré avec une licence publique générale ce qui ne
nécessite aucune licence et est donc libre d’utilisation et certains logiciels sont entièrement
gratuits et le rend très rentable.
	-Au niveau du code source
Linux est un système d'exploitation qui est de base open source. Ce qui signifie que le
code est libre de modification. Les utilisateurs peuvent facilement modifier le code en
fonction de leurs besoins. Ainsi, vous pouvez personnaliser votre propre système
d'exploitation personnel. Cependant, vous devrez avoir les connaissances en programmation
appropriées.
	-Au niveau configuration du système
Le système d'exploitation Linux peut même fonctionner sur des systèmes avec des
configurations faibles. Il n'est pas très gourmand en ressources. Tous les composants comme
la mémoire, l'espace disque et le processeur sont inférieurs dans ce système d'exploitation.
		
		b) __Inconvénients__
	- Au niveau adaptation
Pour les débutants en informatique, il est difficile de comprendre Linux. La plupart des
nouveaux étudiants ont du mal à s'adapter à Linux en raison des terminaux utilisés. Les
terminaux sont une interface de ligne de commande dans laquelle vous devez entrer une
commande spécifique pour effectuer des tâches.
	-Au niveau compatibilité logicielle
Les applications populaires conçues pour Windows et Mac ne sont pas disponibles pour
Linux. De nombreux développeurs ne sont pas intéressés par la création de logiciels pour
Linux en raison de sa faible valeur marchande. Même s'il existe des alternatives à certains
logiciels sous linux mais ils ne peuvent pas correspondre au niveau d'origine.
	-Au niveau compatibilité matérielle
Presque tous les matériels peuvent être connectés à un système d'exploitation Linux. Mais
le problème vient des pilotes. Le concept de pilotes sous Linux est très différent des autres
systèmes d'exploitation. Les pilotes ici sont intégrés dans le noyau. Étant donné que les
pilotes sont déjà préinstallés, le périphérique matériel nouvellement connecté peut ne pas
disposer des pilotes appropriés. Cela rend le périphérique matériel connecté incompatible.
	-Au niveau assistance technique
Il manque du côté du support technique. Le problème ne peut être résolu que si vous
trouvez vous-même une solution. Pour chaque problème, les utilisateurs doivent chercher en
ligne, éventuellement un forum communautaire. Cela ne peut pas garantir d'avoir le problème
exact que l’on recherche.
	-Au niveau mise à jour
Les mises à jour sur les systèmes linux nécessitent une intervention manuelle sur le serveur ce
qui le rend très lent. Les mises à jour sur un serveur linux prend beaucoup de temps si l’on
doit mettre à jour le système.


					**À qui s’adresse le système d’exploitation ?**     (https://www.ionos.fr/digitalguide/serveur/configuration/rocky-linux/)
Le groupe-cible de Rocky Linux est donc déjà bien défini : entreprises et particuliers qui recherchent une distribution Linux fiable, conviviale et gratuite trouveront leur bonheur avec le successeur de CentOS. Les fonctions-clés type solutions d’entreprise, Hyperscale, Cloud et le Calcul Haute Performance sont intégrées, faisant de Rocky Linux une distribution serveur Linux pertinente

				**Quelles sont les alternatives à Rocky Linux ?**
Si vous n’êtes pas convaincu par Rocky Linux, vous trouverez de nombreuses autres distributions Linux pour vos utilisations quotidiennes.

**''Ubuntu''**
Gratuit, open source et géré par une grande communauté, l’un de ses avantages est sa facilité d’utilisation. Il est aussi considéré comme très sûr et stable.

**''openSUSE Leap''**
openSUSE Leap, disponible depuis 2015, est publié par l’entreprise SUSE Software Solutions Germany GmbH,Le système utilise de nombreux composants de la solution payante SUSE Linux, tout en étant open source et gratuit.

**''AlmaLinux''**
Depuis l’annonce de la fin de CentOS, Rocky Linux n’est pas le seul successeur désigné en course. AlmaLinux, lui aussi gratuit et compatible binaire avec Red Hat Enterprise Linux, est développé par une communauté.



__II-firewalld__

Firewalld est un outil de gestion de pare-feu conçu pour les systèmes d'exploitation Linux. Il opère en tant qu'interface pour le framework netfilter du noyau Linux, offrant ainsi des fonctionnalités de pare-feu. Le backend par défaut de firewalld est actuellement nftables. Avant la version 0.6.0, le backend par défaut était iptables. Firewalld utilise des abstractions pour fournir une alternative aux commandes en ligne nft et iptables. Conformément à la convention Unix de nommer les démons système avec la lettre "d" ajoutée, il est appelé firewalld. firewalld est écrit en Python
	
	1 - __Caractéristiques__ (https://access.redhat.com/documentation/fr-fr/red_hat_enterprise_linux/8/html/managing_systems_using_the_rhel_8_web_console/firewalld_managing-firewall-using-the-web-console)

firewalld est un démon de service de pare-feu qui fournit un pare-feu dynamique personnalisable basé sur l'hôte avec une interface D-Bus. Étant dynamique, il permet de créer, de modifier et de supprimer les règles sans avoir à remettre le démon de pare-feu chaque fois que les règles sont modifiées.

firewalld utilisent les concepts de zones et services , qui simplifient la gestion du trafic. Les zones sont des ensembles de règles prédéfinies. Les interfaces réseau et les sources peuvent être attribuées à une zone. Le trafic autorisé dépend du réseau auquel votre ordinateur est connecté et du niveau de sécurité attribué à ce réseau. Les services de pare-feu sont des règles prédéfinies qui renvoient tous les paramètres nécessaires pour autoriser le trafic entrant pour un service spécifique et qui s'appliquent à l'intérieur d'une zone.

Les services utilisent un ou plusieurs ports ou adresses pour la communication en réseau. Les pare-feu filtrent les communications en fonction des ports. Pour permettre le trafic réseau d'un service, ses ports doivent être ouverts . firewalldbloque tout le trafic sur les ports qui ne sont pas désignés comme ouverts. Certaines zones, telles que approuvées , autorisent par défaut tout le trafic.


	2 - __Filtrage en amont et en aval__ (https://access.redhat.com/documentation/fr-fr/red_hat_enterprise_linux/9/html/configuring_firewalls_and_packet_filters/assembly_filtering-forwarded-traffic-between-zones_using-and-configuring-firewalld)

Avec un objet de politique, les utilisateurs peuvent regrouper différentes identités qui requièrent des autorisations similaires dans la politique. L'on peut appliquer des règles en fonction de la direction du trafic.

La fonction d'objets de stratégie permet le filtrage en amont et en aval dans firewalld.
Les politiques supportent la plupart des primitives de firewalld disponibles pour les zones : services, ports,
forward-ports, masquerade, règles riches, etc.



	__3 - Frontaux graphiques (GUI)__
	
firewall-config est un frontal graphique qui est optionnellement inclus avec firewalld,
avec le support de la plupart de ses fonctionnalités.
firewall-applet est un petit utilitaire indicateur d'état qui est optionnellement inclus avec
firewalld. Il peut fournir des notifications de journal d'événements de pare-feu ainsi qu'un
moyen rapide d'ouvrir firewall-config. firewall-applet a été porté de GTK+ au framework Qt au
cours de l'été 2015 suite à la dépréciation des icônes de la barre d'état système du bureau
GNOME.

			**Pourquoi utiliser firewalld ?**

**Simplicité:** Les concepts tels que les zones et les services simplifient grandement la configuration du pare-feu par rapport à la manipulation directe des règles `iptables` ou `nftables`.
    
**Dynamique:** `firewalld` permet des modifications à la volée sans avoir besoin de redémarrer le pare-feu ou de recharger l'ensemble des règles.
    
**Intégration avec NetworkManager:** Cela permet d'assigner automatiquement des interfaces à des zones spécifiques en fonction de la connexion réseau.
    
**Abstraction:** Pour ceux qui ne souhaitent pas s'immerger dans les détails techniques d'`iptables` ou de `nftables`, `firewalld` offre une interface plus intuitive.
    
**Transition vers nftables:** Avec l'adoption croissante de `nftables` comme successeur d'`iptables`, `firewalld` fournit une méthode transparente pour gérer les règles de pare-feu sans avoir à tout réapprendre.



III- __Java__

Java est un langage de programmation de haut niveau, basé sur des classes et orienté objet,
conçu pour avoir le moins de dépendances de mise en œuvre possible. Il s'agit d'un langage de
programmation polyvalent destiné à permettre aux programmeurs d'écrire une fois et de s'exécuter
n'importe où (__WORA__), ce qui signifie que le code Java compilé peut être exécuté sur toutes les plates-
formes qui prennent en charge Java sans qu'il soit nécessaire de le recompiler. La syntaxe de Java est
similaire à celle de C et C++, mais possède moins de facilités de bas niveau que l'une ou l'autre. Le
moteur d'exécution Java fournit des capacités dynamiques (telles que la réflexion et la modification du
code d'exécution) qui ne sont généralement pas disponibles dans les langages compilés traditionnels.
En 2019, Java était l'un des langages de programmation les plus populaires utilisés selon GitHub,
notamment pour les applications web client-serveur, avec un nombre de développeurs rapporté de 9
millions.

Java a été développé à l'origine par James Gosling chez Sun Microsystems. Il a été publié en
mai 1995 en tant que composant central de la plate-forme Java de Sun Microsystems. Les compilateurs
Java, les machines virtuelles et les bibliothèques de classe de l'implémentation originale et de référence
ont été initialement publiés par Sun sous des licences propriétaires. En mai 2007, conformément aux
spécifications du Java Community Process, Sun avait renouvelé la licence de la plupart de ses
technologies Java sous la licence GPL-2.0 uniquement. Oracle propose sa propre machine virtuelle
Java HotSpot, mais la mise en œuvre de référence officielle est la JVM OpenJDK, un logiciel libre et
gratuit utilisé par la plupart des développeurs et la JVM par défaut de presque toutes les distributions
Linux.
En septembre 2022, Java 19 est la dernière version, tandis que Java 17, 11 et 8 sont les versions
actuelles de support à long terme (LTS).

	__1 – Principes__
Cinq objectifs principaux ont présidé à la création du langage Java :

- Il doit être simple, orienté objet et familier;
- Il doit être robuste et sûr;
- Il doit être indépendant de l'architecture et portable;
- Il doit s'exécuter avec de hautes performances;
- Il doit être interprété, threadé et dynamique.



2 – Editions
Sun Microsystems a défini et prend en charge quatre éditions de Java ciblant différents environnements
d'application et a segmenté un grand nombre de ses API afin qu'elles appartiennent à l'une des
plateformes. Les plates-formes sont les suivantes :

- Java Card pour les cartes à puce;
- Java Platform, Micro Edition (Java ME) - ciblant les environnements aux ressources
limitées;
- Java Platform, Standard Edition (Java SE) - ciblant les environnements de stations de
travail;
- Java Platform, Enterprise Edition (Java EE) - ciblant les grandes entreprises distribuées
ou les environnements Internet.

Les classes des API Java sont organisées en groupes distincts appelés paquets. Chaque
paquetage contient un ensemble d'interfaces, de classes, de sous-paquetages et d'exceptions
connexes.
Sun a également fourni une édition appelée Personal Java qui a été remplacée par des
paires configuration-profil Java ME ultérieures, basées sur les normes.

3 - Système d'exécution
a) Performance
Les programmes écrits en Java ont la réputation d'être plus lents et de nécessiter plus de
mémoire que ceux écrits en C++. Cependant, la vitesse d'exécution des programmes Java s'est
améliorée de manière significative avec l'introduction de la compilation juste-à-temps en
1997/1998 pour Java 1.1, l'ajout de caractéristiques du langage permettant une meilleure
analyse du code (telles que les classes internes, la classe StringBuilder, les assertions
optionnelles, etc.) et les optimisations de la machine virtuelle Java, comme HotSpot qui est
devenu la JVM par défaut de Sun en 2000. Avec Java 1.5, les performances ont été améliorées
grâce à l'ajout du paquetage java.util.concurrent, y compris les implémentations sans verrou des
ConcurrentMaps et d'autres collections multicœurs, et elles ont encore été améliorées avec Java

4 – Syntaxe
La syntaxe de Java est largement influencée par le C++ et le C. Contrairement au C++,
qui combine la syntaxe de la programmation structurée, générique et orientée objet, Java a été
construit presque exclusivement comme un langage orienté objet. Tout le code est écrit à
l'intérieur de classes, et chaque élément de données est un objet, à l'exception des types de
données primitifs (c'est-à-dire les entiers, les nombres à virgule flottante, les valeurs
booléennes et les caractères), qui ne sont pas des objets pour des raisons de performance. Java
réutilise certains aspects populaires du C++ (comme la méthode printf).
Contrairement au C++, Java ne prend pas en charge la surcharge des opérateurs ni
l'héritage multiple pour les classes, bien que l'héritage multiple soit pris en charge pour les
interfaces.
Java utilise des commentaires similaires à ceux du C++. Il existe trois styles de
commentaires différents : un style à ligne unique marqué par deux barres obliques (//), un style
à lignes multiples ouvert par /* et fermé par */, et le style de commentaire Javadoc ouvert par
/** et fermé par */. Le style de commentaire Javadoc permet à l'utilisateur d'exécuter
l'exécutable Javadoc afin de créer une documentation pour le programme et peut être lu par
certains environnements de développement intégrés (IDE) tels qu'Eclipse pour permettre aux
développeurs d'accéder à la documentation dans l'IDE.

a- Exemple de Hello World
Le programme traditionnel Hello world peut être écrit en Java comme suit :

				__Image__

	
__IV – Secure Shell (SSH)__

Le protocole Secure Shell (SSH) est un protocole de réseau cryptographique permettant
d'exploiter des services de réseau en toute sécurité sur un réseau non sécurisé. Ses applications
les plus importantes sont la connexion à distance et l'exécution de lignes de commande.
Les applications SSH sont basées sur une architecture client-serveur, connectant une
instance client SSH à un serveur SSH. SSH fonctionne comme une suite de protocoles en
couches comprenant trois composants hiérarchiques principaux : la couche de transport fournit
l'authentification, la confidentialité et l'intégrité du serveur ; le protocole d'authentification de
l'utilisateur valide l'utilisateur auprès du serveur ; et le protocole de connexion multiplexe le
tunnel crypté en plusieurs canaux de communication logiques.

				Historique
SSH a été conçu pour les systèmes d'exploitation de type Unix, en remplacement de
Telnet et des protocoles shell Unix distants non sécurisés, tels que le Berkeley Remote Shell
(rsh) et les protocoles connexes rlogin et rexec, qui utilisent tous une transmission en clair non
sécurisée des jetons d'authentification.

SSH a été conçu en 1995 par l'informaticien finlandais Tatu Ylönen. Le développement
ultérieur de la suite de protocoles s'est fait au sein de plusieurs groupes de développeurs,
produisant plusieurs variantes d'implémentation. La spécification du protocole distingue deux
versions majeures, appelées SSH-1 et SSH-2. La pile logicielle la plus couramment
implémentée est OpenSSH, publiée en 1999 sous forme de logiciel libre par les développeurs
d'OpenBSD. Des implémentations sont distribuées pour tous les types de systèmes
d'exploitation couramment utilisés, y compris les systèmes embarqués.


	
	2 – Utilisation
SSH est un protocole qui peut être utilisé pour de nombreuses applications sur de
nombreuses plates-formes, notamment la plupart des variantes d'Unix (Linux, les BSD, y
compris macOS d'Apple, et Solaris), ainsi que Microsoft Windows. 

utilisation possible :
Pour la connexion à un shell sur un hôte distant (remplaçant Telnet et rlogin);
Pour exécuter une seule commande sur un hôte distant (en remplacement de rsh)
Pour configurer la connexion automatique (sans mot de passe) à un serveur distant (par
exemple, en utilisant OpenSSH)
En combinaison avec rsync pour sauvegarder, copier et mettre en miroir des fichiers de
manière efficace et sécurisée.
Pour la redirection d'un port
Pour la création de tunnels (à ne pas confondre avec un VPN, qui achemine les paquets
entre différents réseaux, ou relie deux domaines de diffusion en un seul).
Pour l'utilisation en tant que VPN crypté à part entière. Notez que seuls le serveur et le
client OpenSSH supportent cette fonctionnalité.
Pour naviguer sur le Web via une connexion proxy chiffrée avec des clients SSH qui
prennent en charge le protocole SOCKS.
Pour monter en toute sécurité un répertoire sur un serveur distant en tant que système de
fichiers sur un ordinateur local à l'aide de SSHFS.
Pour la surveillance et la gestion automatisées à distance des serveurs par le biais d'un
ou plusieurs des mécanismes mentionnés ci-dessus.
Pour le développement sur un appareil mobile ou embarqué qui prend en charge SSH.•
Pour la sécurisation des protocoles de transfert de fichiers.


	- File transfer protocols
Les protocoles Secure Shell sont utilisés dans plusieurs mécanismes de transfert de
fichiers.
- Secure copy (SCP), qui a évolué à partir du protocole RCP sur SSH rsync, destiné à être
plus efficace que SCPn s’exécute généralement sur une connexion SSH.
- SSH File Transfer Protocol (SFTP), une alternative sécurisée à FTP (à ne pas confondre
avec FTP over SSH ou FTPS)
- Files transferred over shell protocol (alias FISH), lancé en 1998, qui a évolué à partir des
commandes du shell Unix sur SSH.
- Fast and Secure Protocol (FASP), alias Aspera, utilise SSH pour le contrôle et les ports
UDP pour le transfert de données.
	
	4 – Algorithmes
EdDSA, ECDSA, RSA et DSA pour la cryptographie à clé publique.
ECDH et Diffie-Hellman pour l'échange de clés.
HMAC, AEAD et UMAC pour le MAC.
AES (et RC4, 3DES, DES[28] dépréciés) pour le chiffrement symétrique.
AES-GCM et ChaCha20-Poly1305 pour le chiffrement AEAD.
SHA (et MD5 déprécié) pour l'empreinte de la clé.
tait aux attaquants d'exécuter du code arbitraire avec les privilèges du démon SSH, typiquement
root.
le mode CTR, le mode compteur, au lieu du mode CBC, car cela rend SSH résistant à l'attaque.



__V – Rundeck__

				Présentation
Rundeck est une automatisation de runbooks qui vous permet, à vous et à vos collègues, d'accéder en libre-service aux processus et aux outils dont ils ont besoin pour accomplir leur travail.

Lorsqu'il est utilisé pour la gestion des incidents, Rundeck vous aidera à avoir des incidents plus courts et moins d'escalades.

Lorsqu'il est utilisé pour des travaux d'opérations générales, Rundeck contribuera à alléger le travail fastidieux et répétitif qui consomme actuellement trop de temps de votre équipe.

Pour plus d'informations sur les cas d'utilisation, visitez le site Rundeck.

Avec Rundeck, il est simple et facile de créer des flux de travail (appelés « tâches ») à partir de n'importe lequel de vos outils ou scripts existants. Déclenchez des tâches Rundeck à partir de l'interface graphique Web, de l'API, de la CLI ou selon une planification. Les fonctionnalités de contrôle d'accès de Rundeck facilitent la délégation en toute sécurité du contrôle des tâches à ceux qui sont traditionnellement extérieurs aux opérations.

Rundeck a été conçu pour accepter la réalité selon laquelle les infrastructures et les outils hétérogènes sont une réalité dans toute organisation de grande taille. C'est pourquoi Rundeck ne vous oblige pas à remplacer les scripts, commandes ou outils que vous utilisez aujourd'hui. Vous utilisez Rundeck pour exécuter des flux de travail dans votre automatisation existante (par exemple, Ansible, Puppet, Chef, Jenkins, Docker, Kubernetes, les outils existants et tous vos scripts/API personnalisés) ou pour automatiser rapidement des procédures auparavant manuelles. Avec Rundeck, vous pouvez réutiliser les compétences en automatisation que vous possédez déjà et en ajouter de nouvelles si nécessaire.

Prêt à l'emploi, Rundeck vous offre des fonctionnalités qui seraient coûteuses à développer et à maintenir en interne : contrôle des flux de travail, planification, gestion des erreurs, journalisation, contrôle d'accès, passage d'options, filtrage des journaux, interface graphique Web, API REST (avec outils CLI ) et l'intégration avec des sources externes pour l'authentification, le modèle de ressource et les données d'option.



			open source
Rundeck Open Source est un logiciel open source gratuit sous licence Apache Software License v2.0., et vous pouvez participer au projet sur GitHub. Pour ceux qui écrivent et exécutent des tâches Rundeck à petite échelle (par exemple, utilisation limitée ou au sein d'une équipe), le Rundeck open source vous offre les fonctionnalités dont vous avez besoin, gratuitement, pour toujours .




		Points forts des fonctionnalités de Rundeck
Exécution de commandes distribuées
Flux de travail (y compris le passage d'options, les conditions, la gestion des erreurs et plusieurs stratégies de flux de travail)
Système d'exécution enfichable (SSH et WinRM par défaut ; PowerShell disponible)
Modèle de ressources enfichable (obtenez des détails sur votre infrastructure à partir de systèmes externes)
Exécution de tâches à la demande (interface graphique Web, API ou CLI) ou planifiée
Magasin de clés sécurisé pour les mots de passe et les clés
Politique de contrôle d'accès basée sur les rôles avec prise en charge de LDAP/ActiveDirectory/SSO
Outils d’édition/gestion des politiques de contrôle d’accès
Historique et journaux d'audit
Utilisez n’importe quel langage de script




Chapitre IV : Concepts

__Projets__
Un projet est un lieu pour séparer les activités de gestion. Toutes les activités de Rundeck se déroulent dans le contexte d'un projet. Plusieurs projets peuvent être gérés sur le même serveur Rundeck. Les projets sont indépendants les uns des autres, vous pouvez donc les utiliser pour organiser des systèmes non liés au sein d'une seule installation Rundeck. Cela peut être utile pour gérer différentes équipes, infrastructures, environnements ou applications.

Les projets peuvent être archivés et importés sur d'autres serveurs Rundeck pour aider à promouvoir les changements entre les environnements.

Une nouvelle installation ne contiendra aucun projet, Rundeck vous présentera donc une boîte de dialogue pour en créer un.




__Inventaire__
Une source de modèle de ressource est un moyen de partager des informations sur votre infrastructure avec Rundeck en tant que nœuds .
				Les sources de données sont généralement des systèmes tiers




Pourquoi créer un __Job__ ?

On pourrait constater que certaines exécutions de commandes sont effectuées de manière répétée et représentent peut-être ce qui est devenu une procédure de routine.
Un autre utilisateur de votre groupe a besoin d'une interface simple en libre-service pour exécuter une procédure sur un ensemble de nœuds.
Les processus de routine doivent être encapsulés et devenir la base d’autres procédures de routine.


Jobs
Les Jobs fournissent un moyen d'encapsuler un processus. Un Job est une configuration représentant les options d'entrée, les étapes
	du processus, une expression de filtre qui correspond aux nœuds où ces étapes seront exécutées et des paramètres de contrôle 
	d'exécution qui spécifient si les étapes sont exécutées en parallèle et que faire si une erreur se produit dans l'une d'entre elles. des marches.

	L'accès aux travaux est régi par une politique de contrôle d'accès que vous définissez en déclarant comment les utilisateurs 
	reçoivent des privilèges pour lire, créer, modifier, exécuter et supprimer des travaux.

	Rundeck vous permet d'organiser et d'exécuter des Jobs et d'observer la progression pendant l'exécution du Job. Vous pouvez afficher une liste 
	des Jobs en cours d'exécution ou explorer le résultat des étapes d'exécution individuelles. 
	Les exécutions de tâches peuvent également être abandonnées si elles doivent être arrêtées.

	Chaque exécution de Job est stockée et contient des informations sur les nœuds où les étapes ont été exécutées, le succès et la durée de 
	chaque étape. La sortie d'exécution de la tâche peut être téléchargée, transmise à un magasin de journaux externe ou envoyée dans le cadre 
	d'une notification par e-mail, IRC, système de billetterie ou d'autres destinations.


workflow (Flux de travaux)
		La fonctionnalité la plus basique du Job est sa capacité à exécuter une ou plusieurs étapes. Cette séquence d'étapes s'appelle un workflow .

			* Paramètres de contrôle du flux de travail
				L'exécution du workflow est contrôlée par deux paramètres importants : Gestion d'un échec d'étape et Stratégie .

					- Si une étape échoue : cela gère ce qu'il faut faire si une étape entraîne une erreur :
						Arrêter à l'étape ayant échoué : échouer immédiatement (par défaut).
						Exécutez les étapes restantes avant d'échouer : passez aux étapes suivantes et faites échouer la tâche à la fin.

						La valeur par défaut est d'échouer immédiatement, mais selon la procédure en cours, il est possible de choisir de poursuivre l'exécution.

					- Stratégie : contrôle l'ordre d'exécution des étapes et l'envoi des commandes aux nœuds : orienté nœud et orienté étape .
						Node First : exécute le flux de travail complet sur chaque nœud avant le nœud suivant. (défaut)
						Séquentiel : exécute chaque étape sur tous les nœuds avant l'étape suivante.
						Parallèle : Exécute toutes les étapes en parallèle.



Un __nœud__ est une ressource qui est une instance physique ou virtuelle d'un hôte accessible par le réseau. Les nœuds ont quelques attributs de base, mais les attributs d'un nœud peuvent être étendus pour inclure des paires clé/valeur nommées arbitrairement. Chaque nœud a un nom d'identification unique. En plus de name, certaines métadonnées sont obligatoires (comme hostnameet username) et d'autres sont facultatives. Les attributs décrivent généralement les propriétés d'un nœud ou reflètent l'état du nœud. L'un des attributs intégrés d'un nœud est appelé « balises », qui sont une liste de classifications ou de catégories concernant ce nœud.




Une __commande__ est une chaîne exécutable unique exécutée sur un nœud. Rundeck appelle des commandes sur les nœuds via un exécuteur de nœud qui évalue la chaîne de commande et l'exécute. Les exécuteurs de nœud évaluent la chaîne de commande dans un contexte de données contenant des informations sur la ressource Node. Les chaînes de commande peuvent référencer ces données et ainsi éviter de coder en dur des valeurs spécifiques au nœud ou à l'environnement.

La console graphique Rundeck offre la possibilité d'exécuter des commandes sur un ensemble de ressources Node filtrées. La page de commande peut accepter n'importe quelle chaîne de commande que vous pourriez exécuter via une commande SSH




__Activité__
	L'historique d'exécution des commandes et des Jobs est stocké par le serveur Rundeck. L'historique d'exécution peut être filtré et visualisé dans la page "Activité".



Les __webhooks__ constituent un moyen standard du secteur permettant aux applications Internet de communiquer entre elles. Les Webhooks Rundeck sont un point d'entrée vers l'automatisation avec Rundeck. Un Webhook peut être configuré pour accepter les charges utiles entrantes et déclencher les tâches Rundeck. Les événements Webhook sont gérés par les plugins Webhook Event Rundeck.




		__PARTIE III : MISE EN ŒUVRE DU PROJET__
Chapitre VI : Implémentation de la solution


I- Critique
	1- Architecture existante
				__schema de l'architecture existant__
				
* AdminSys: répresente les administrateur système ou le groupe d'administration.
* Serveur d'administration: Ce serveur sert de point central pour la gestion des différents services en aval.
* Les services gérés:
	- BNETD
	- Deu x serveurs MySQL: bd1 et bd2
	- SWAN PRO
	- OGOSecurity
	- ONECI
	- Orange CI 


	2- Architecture Finale
				__schema de la future architecture__

Rundeck remplace le "serveur d'administration" de notre architecture existante. Rundeck est la plateforme d'automatisation de serveurs qui aide à automatiser les tâches administratives routinières et à exécuter des scripts sur nos différents serveurs.

Dans cette configuration, nous avons opté pour une architecture client-serveur car elle offre des avantages considérables en termes de simplicité de configuration et d'efficacité dans la résolution de problèmes. Cette approche facilite également l'extension du réseau et permet d'intégrer une variété de serveurs hétérogènes au sein du système.


II-Installation des outils
	1- Système d'exploitation (Rocky linux)
	
	Cette partie présente les étapes détaillées de l'installation d'une version 64 bits de la
distribution Rocky Linux sur un système autonome. Nous effectuerons une installation de classe
serveur en utilisant une image d'installation du système d'exploitation téléchargée depuis le site Web
du projet Rocky Linux. Nous allons suivre les étapes d'installation et de personnalisation dans les
sections suivantes.

			**Conditions préalables à l'installation du système d'exploitation**
			
Avant toute chose, il est nécessaire de procéder au téléchargement de l'image ISO qui sera utilisée pour installer Rocky Linux. Vous pouvez obtenir la version la plus récente de l'ISO de Rocky Linux nécessaire à cette installation en suivant ce lien :
https://www.rockylinux.org/download/

 S'assurer que l'interface UEFI (Unified Extensible Firmware Interface) ou le BIOS (Basic Input/Output System) du système doivent être préconfigurés pour démarrer à partir du support correct.


								**Installation**

Insérez et démarrez à partir du support d'installation (disque optique, clé USB, etc.). Une
fois que l'ordinateur a démarré, l'écran de démarrage de l'installation de Rocky Linux.  


		__Options de démarrage pour l'installation de Rocky Linux__

Vous pouvez laisser le voyant sur “installer Rocky Linux ” et appuyer sur la touche Entrée à
tout moment pour lancer le processus immédiatement.

 - Résumé de l'installation
			__Résumé de l'installation__
L'écran Résumé de l'installation est une zone tout-en-un où vous prenez les décisions
importantes concernant le système d'exploitation à installer. L'écran est divisé en
plusieurs sections :
* Localisation : (Clavier, Prise en charge de la langue, et Heure et date)
* Logiciel : (Source d'installation et Sélection du logiciel)
* Système : (Destination de l'installation, Réseau et nom d'hôte, KDUMP et  Profit de securité)
* Paramètre Utilisateur (Mot de passe administrateur et création utilisateur)


				- Section Localisation
Cette section est utilisée pour personnaliser les éléments liés à la localisation du système. Cela
comprend : le clavier, la prise en charge de la langue, l'heure et la date.


				- Section Système
La section Système permet de personnaliser et de modifier la configuration matérielle du système que vous installez. C'est dans cette section que vous pouvez configurer les partitions de disque, créer des volumes logiques et définir d'autres paramètres de stockage selon vos besoins.


		- Section Logiciel
Dans la section 'Logiciel' de l'écran de résumé de l'installation, vous avez la possibilité de définir l'origine des paquets logiciels et de choisir quels ensembles de logiciels seront installés sur le système. La 'Source d'installation' vous permet de spécifier d'où les paquets seront téléchargés, que ce soit à partir d'un disque local, d'une image ISO, ou via un réseau tel qu'un miroir de dépôt en ligne. La 'Sélection du logiciel', quant à elle, vous donne la possibilité de sélectionner des groupes de paquets prédéfinis pour installer des environnements de bureau, des serveurs, ou des ensembles de développement, vous permettant ainsi de personnaliser l'installation selon vos besoins spécifiques."

		- Section Paramètres Utilisateur
Dans cette section, vous allez établir le 'Mot de passe administrateur', qui est crucial pour la gestion des privilèges et l'accès root. Il est important de choisir un mot de passe fort et sécurisé. Ensuite, vous avez la possibilité de 'Créer un utilisateur', ce qui vous permet de définir un compte pour l'utilisation quotidienne, évitant ainsi de fonctionner en permanence avec les droits d'administrateur. Lors de cette étape, vous pouvez également attribuer des privilèges d'administrateur au nouvel utilisateur si nécessaire."


Une fois que vous êtes satisfait de vos choix pour les différentes tâches d'installation, la phase
suivante du processus d'installation consiste à commencer l'installation proprement dite.

	__choix effectués__ 
	__Installation__ 

Une fois que vous avez effectué toutes les sous-tâches obligatoires et que le programme d'installation a
suivi son cours, un écran final de progression de l'installation vous est présenté avec un message de fin.
Enfin, terminez toute la procédure en cliquant sur le bouton Reboot System. Le système
redémarre.

	__fin d'installation__



			Première connection
Le système est maintenant configuré et prêt à être utilisé. Vous verrez la console Rocky Linux.
			__première connection__

	2-Firewalld
firewalld est installé par défaut sur certaines distributions Linux, tel que Rocky Linux. Cependant, il peut être nécessaire que vous installiez firewalld vous-même. Vous pouvez le faire en utilisant le gestionnaire de paquets dnf de Rocky  linux :

$ sudo dnf install firewalld -y
	
	__firewalld__

Après avoir installé firewalld, vous devrez activer le service à l'aide de systemctl. N'oubliez pas que
l'activation de firewalld entraînera le démarrage du service au démarrage.

$ sudo systemctl enable firewalld
$ sudo systemctl start firewalld

Vous pouvez vérifier que le service est en cours d'exécution et joignable en tapant

$ sudo firewall-cmd --state

	__status-firewalld__

	3- SSH 
	
Pour garantir une connexion à distance sécurisée des administrateurs à notre serveur Rundeck, ainsi que pour autoriser le serveur Rundeck à accéder en toute sécurité à nos différents serveurs clients, nous procéderons à l'installation d'openSSH :

* Pour installer le client OpenSSH, utilisez la commande :
$ sudo dnf install openssh-client -y 

* Pour installer le serveur OpenSSH, tapez :
- $ sudo dnf install openssh-server -y


Il est à noter qu'openSSH est généralement installé par défaut sur le système Rocky Linux.

	4- Rundeck

	__Installation-Rundeck__

Remarque : //executer ces commandes en tant que utilisateur root//

$ curl https://raw.githubusercontent.com/rundeck/packaging/main/scripts/rpm-setup.sh 2> /dev/null | bash -s rundeck

ce script ajoute le repo yum de Rundeck

$ yum install java-1.8.0 rundeck 

cette commande installe la version 1.8.0 de java et en suite installe l'outil rundeck

Java est requis pour l'installation de Rundeck car Rundeck est écrit en Java. Le logiciel est une application Java basée sur le framework Grails, qui permet la planification et la gestion des tâches automatisées. Pour que Rundeck fonctionne, il doit être exécuté dans un environnement Java Runtime Environment (JRE) ou Java Development Kit (JDK), qui fournit la plate-forme nécessaire pour exécuter des applications Java.


$ service rundeckd start 

Pour demarrer le service rundeck


III- Configuration 


				* Firewall

Rundeck écoute sur le port 4440/tcp pour les services web HTTP et 4443 pour HTTPS.
Ouvrez ce port sur le pare-feu pour permettre un accès externe à Rundeck ;

$ sudo firewall-cmd --add-port=4440/tcp --permanent
$ sudo firewall-cmd --reload
				__config-firewalld__


				* Secure Shell (SSH)
Commençons par creer un user que rundeck utilisera pour la connexion sur les differents
nodes distants . Par defaut ce utilisateur est “rundeck”. Sur les differents nodes, on vas dans un
premier temps creer l’utilisateur rundeck puis deployer les clé publiques du serveurs rundeck
sur ces machines pour assurer une communication par clé

		a) Création de l’utilisateur rundeck
		
executer les commandes en tant que utilisateur root (super utilisateur)
pour créer l’utilisateur
$ useradd rundeck

$ echo “rundeck ALL=(ALL) NOPASSD:ALL” > [[/etc/sudoers.d/rundeck]]

cette commande crée une nouvelle règle de sudo dans le fichier /etc/sudoers.d/rundeck, autorisant l'utilisateur rundeck à exécuter n'importe quelle commande sur le système sans avoir besoin de saisir un mot de passe. Cela peut être nécessaire pour automatiser les tâches administratives qui sont effectuées par des scripts ou des applications qui fonctionnent sous l'utilisateur rundeck.
		
		b) Deployer la clé publique de l’user rundeck sur les differents machines

les clé du serveur rundeck ont été générées automatiquement pendant l’installation de
rundeck et se trouvent dans le repertoire : [[/var/lib/rundeck/.ssh]]

				__key-pub__

			* Rundeck

Les fichiers de configuration de rundeck :
			__Fichiers de configuration__



La configuration est spécifiée dans un certain nombre de fichiers de configuration
standard de Rundeck générés pendant le processus d'installation.
L'objectif de chaque fichier de configuration est décrit dans sa propre section.


	**Configuration du serveur**


vim /etc/rundeck/rundeck-config.properties

# grails.serverURL=http://localhost:4440
grails.serverURL=http://ip_srv:4440

ip_srv = adresse Ip de votre serveur 



vim /etc/rundeck/framework.properties

framework.server.name = ip_srv
framework.server.hostname = ip_srv
framework.server.port = 4440
framework.server.url = http://ip_srv:4440

Suite aux changements apportés aux fichiers de configuration, il est nécessaire de redémarrer le service rundeckd afin que les modifications soient appliquées.

$ systemctl restart rundeckd

$ systemctl status rundeckd

cette commande vous permet de verifier létét du service rundeckd

$ tail -f [[/var/log/rundeck/rudeck.log]]

cette commande afficher en temps réel les nouvelles lignes ajoutées à la fin du fichier de log rundeck.log 





Pour acceder a linterface web de runcdeck, lancer dans un navigateur l'URL suivant " http://ip_svr:4440"
ou ip_svr répresente l'IP du serveur rundeck, qui dans notre cas est192.168.71.134
Et nous pouvons voir s'afficher la page de connexion de Rundeck.
 
					__interface de connexion rundeck__

Par defaut l'utilisateur et le mot de passe par defaut est : "admin"


CHAPITRE : Test et Reultats

I-Administration et execution des jobs sur les nodes 


Il est possible de changer l'utilisateur et le mot de passe par defaut de Rundeck
Pour le faire il faut ajouter quelque ligne a notre fichier de configuration realm.properties. 
La syntaxe se presente comme suit :

__imgs__



Nous voila dans l’interface de rundeck

__imgs3-1__

Pour commencer notre automatisation, l’on doit commencer d’abord par creer un projet
•On selectionne alors “Create New Project”, nous serons redirigé vers une interface pour
remplire les differents details du projet.
•Ensuite on fait “create” apres que l’on ai fait create, nous somme redirigé vers la rubrique pour
ajout de noeuds

3-2


Ajout des nodes
cette configuration se fait dans le répertoire "var/lib/rundeck/project/nom_project/etc/re" precisons que
nom_project est un repertoire portant un nom de projet que vous desirez. Laba nous creons un
fichier resources.xml qui vas contenir les syntaxes pour la configuration des nodes

__imgs-3-3__

l’on peut configurer autant de nodes que l’on veux dans ce fichier. Ensuite on enregistre puis on
se retourne sur notre interface pour ajouter notre fichier

On choisir “Add a new Node Source” > “File” ; puis se fait maintenant la configuration:
Format : on choisis resourcexml
File path : /var/lib/rundeck/project/folder/etc/resources.xml
puis on fait “save”

3-4
3-5

apres ca on verra aparaitre les noeuds automatiquement dans l'onglet noeuds
3-6



Configuration de jobs

nous nous rendons dans l'onglet travaux (Job)

4-1

Cliquez sur Create a new job 
Et renseigner les différents champs
4-2


En suite definir le workfow 

4-3

dans notre cas ce job permettra de :
 
afficher le chemin du répertoire courant 
lister le contenu du répertoire courant
afficher le contenu du fichier nommé "about.txt" contenu sur chaque serveur distant 


Selctionner les noeuds sur lesquels executé le job

4-4

exécuter le job nommé "hello"

4-5

sortie de journal du job

ACtivités

4-6





















				**ANNEXE : Description de quelque fichiers de configuration** 

	✔ admin.aclpolicy
Il sagit de la politique de contrôle d'accès de l'administrateur définie avec un
document aclpolicy.
le fichier régit l'accès pour le groupe et le rôle "admin".
	
	✔ framework.properties
c’est le fichier de configuration utilisé par les outils shell et les services de base
de Rundeck. Ce fichier sera créé pour vous au moment de l'installation. Il contient quelques
paramètres importants :

	- framework.server.hostname : nom d'hôte du nœud de serveur Rundeck.
	- framework.server.name : nom (identité) du nœud de serveur Rundeck.
	- framework.projects.dir : Chemin d'accès au répertoire contenant les répertoires des
projets Rundeck. La valeur par défaut est $RDECK_BASE/projets.
	- framework.var.dir : répertoire de base pour les fichiers de sortie et temporaires utilisés
par le serveur et les outils CLI. La valeur par défaut est $RDECK_BASE/var.
	- framework.logs.dir : Répertoire pour les fichiers journaux écrits par les services
principaux et les exécutions de tâches du serveur Rundeck. La valeur par défaut est
$RDECK_BASE/var/logs.
	- framework.server.username : Nom d'utilisateur pour la connexion au serveur Rundeck.
	- framework.server.password : Mot de passe pour la connexion au serveur Rundeck.
	- framework.rundeck.url : URL de base pour le serveur Rundeck.
	- framework.ssh.keypath : Chemin d'accès au fichier de clé privée SSH utilisé pour
les connexions SSH.
	- framework.ssh.user : Nom d'utilisateur par défaut pour les connexions SSH, s'il
n'est pas remplacé par une valeur spécifique au nœud.
	- framework.ssh-connection-timeout : délai d'attente en millisecondes pour les
connexions SSH. La valeur par défaut est "0" (pas de délai d'attente). Vous pouvez
modifier cette valeur pour changer le délai de connexion/socket. (Déclassé :
framework.ssh.timeout.)
	- framework.ssh-command-timeout : délai d'attente en millisecondes pour les
commandes SSH. La valeur par défaut est "0" (pas de délai d'attente). Vous pouvez
modifier cette valeur pour changer le temps maximum autorisé pour l'exécution des
commandes SSH.

	✔ log4.properties – Legacy
Rundeck utilise log4j comme outil de journalisation des applications. Ce
fichier définit la configuration de la journalisation pour le serveur Rundeck.
	
	✔ Profile
Variables d'environnement du shell utilisées par les outils du shell. Ce
fichier contient plusieurs paramètres nécessaires au démarrage des outils du shell
comme umask, Java home et classpath, et les options SSL.

	✔ project.properties
Le fichier de configuration du projet Rundeck lorsque vous utilisez des
définitions de projet basées sur le système de fichiers. L'un de ces fichiers est généré
au moment de la configuration du projet. Chaque projet possède un répertoire dans le
répertoire des projets Rundeck, et le fichier de configuration se trouve dans le sous-
répertoire etc :

$RDECK_BASE/projects/[PROJECT-NAME]/etc/project.properties

project.name : Déclare le nom du projet.
project.ssh-authentication Type d'authentification SSH (par exemple, privateKey).
project.ssh-keypath Déclare le fichier d'identification SSH. (Remarque : il ne s'agit pas
d'un chemin de stockage de clés mais d'un chemin de système de fichiers local).
service.FileCopier.default.provider Plugin de copie de fichier par défaut.
service.NodeExecutor.default.provider Plugin d'exécution de nœud par défaut.
resources.source Définit une source de modèle de ressource voir Sources de modèle
de ressource.
project.globals.X Définit une variable globale du projet.
	
	✔ realm.properties
Répertoire utilisateur du fichier de propriétés lorsque PropertyFileLoginModule
est utilisé. Spécifié à partir de jaas-loginmodule.conf.
	
	✔ rundeck-config.properties
Il s'agit du principal fichier de configuration de la webapp Rundeck. Il
définit le niveau de connexion par défaut, la configuration des sources de données et
la personnalisation de l'interface graphique.




















C- Administration et execution des jobs sur les nodes
Nous voila dans l’interface de rundeck
45Pour commencer notre automatisation, l’on doit commencer d’abord par creer un projet
•On selectionne alors “Create New Project”, nous serons redirigé vers une interface pour
remplire les differents details du projet.
•Ensuite on fait “create” apres que l’on ai fait create, nous somme redirigé vers la rubrique pour
ajout de noeuds
Ajout des nodes
cette configuration se fait dans le fichier var/lib/rundeck/project/nom_project/etc precisons que
nom_project est un repertoire portant un nom de projet que vous desirez. Laba nous creons un
fichier resources.xml qui vas contenir les syntaxes pour la configuration des nodes
46l’on peut configurer autant de nodes que l’on veux dans ce fichier. Ensuite on enregistre puis on
se retourne sur notre interface pour ajouter notre fichier
On choisir “Add a new Node Source” > “File” ; puis se fait maintenant la configuration:
Format : on choisis resourcexml
File path : /var/lib/rundeck/project/folder/etc/resources.xml
puis on fait “save”
apres ca on verra aparaitre les noeuds automatiquement dans noeuds
Configuration de jobs
47•
48
Create a new jobla partie script est l’endroit ou l’on definir les actions a effectuer sur les nodes. Dans notre exemple on
liste avec la commade ls -al les fichier contenu dans le repertoire courant des machines
•
49
Renseigner l’identité du job (nom, description, script a executer) etc .50
•Chosis le node sur lequel on execute le job
•Execute le job sur le node local et le node distant ( dans notre exemple)•
run on the 2 nodes’.
Nos job marche tres bien . On peut aller plus loin pour d’autres configurations
51Conclusion partielle
Dans cette partie, nous avons appris à installer l'édition communautaire de Rundeck sur notre
serveur Rocky Linx. Vous pouvez effectuer quelques configurations et créer un nouveau projet afin de
commencer à utiliser votre Rundeck.
52CONCLUSION
Ce mémoire avait pour ambition de proposer une solution d’automatisation de taches afin
d’automatiser les tache de la structure d’acceuil Smile.
Il a fallu dans un premier temps définir la notion même d’automatisation, examiner les caractéristiques
inhérentes au l’automatisation et a chercher un outil convenable pour l’entreprise.
Il convenait alors de s'intéresser aux outils a utiliser ainsi que des configurations appropriées pour
l’automatisation sur les serveurs distant. L’automatisation est un facteur important dans le domaine
informatique. Il est donc important d’adopter cette pratique afin d’avoir de bonne performance et une
evolutivité fluide et rapide de nos infrastructures et de nos systemes.
53BIBLIOGRAPHIE
➢ Guide d’administration Rundeck Guide d’administration fournit par l’éditeur
(Rundeck CE)
54WEBOGRAPHIE
1) https://www.rundeck.com/
2) https://docs.rundeck.com/docs/administration/install/installing-rundeck.html
3) https://www.devopsschool.com/blog/how-to-install-and-configure-rundeck/
4) https://linuxways.net/ubuntu/how-to-install-rundeck-on-ubuntu-20-04/
5) https://docs.rundeck.com/docs/manual/creating-jobs.html
6) https://blog.octo.com/devs-ops-tous-sur-le-pont-avec-rundeck/
7) http://easy-bi.org/blog/rundeck-planifiez-vos-taches-ingrates/
8) https://docs.rundeck.com/docs/manual/05-nodes.html
9) https://docs.rundeck.com/docs/manual/projects/node-execution/ssh.html
10) https://docs.rundeck.com/docs/manual/projects/node-execution/script.html
				TABLE DES MATIERES




INTRODUCTION
PARTIE 1 : CADRE DE REFERENCE
Chapitre 1 : Présentation de la structure d’acceuil .....................………………………..................10
I- Présentation de la structure Smile .........................................................……………………………..10
II- Présentation de la direction d’accueil SMILE/SYNERTECH .......................……………………....11
Chapitre 2 : Etude de l’existant .......................................................................………………………12
I- L’existant ......................................................................................…………………………………...12
II- Objectifs attendus ..........................................................................………………………………….13
PARTIE 2 : ETUDE TECHNIQUES
Chapitre 3 : Présentation des outils du projet ………………………...............................................15
I- Le Système Rocky Linux ..................................................................………………………………..15
II- Firewall-CMD .............................................................................…………………………………..15
III- Java ..........................................................................................…………………………………….17
IV- SSH ....................................................................…................……………………………………...21
V – Rundeck .............................................................….....................…………………………………..24
Chapitre 4 : Justification du choix des outils ......…...........................................…………………….26
A - Le Système Rocky Linux.................................…...............................……………………………...26
B- Firewall-CMD ...............................................…..............................………………………………...26
C- Java ...........................................................................................…………………………………….27
D- SSH ..........................................................................................……………………………………..27
E- Rundeck .....................................................................................…………………………………....29
PARTIE 3 : MISE EN OEUVRE DU PROJET
Chapitre 6 : Implementation de la solution ...……………............................................................….31
A - Description de l’architecture finale ………………………………………………………………. 31
B- Déploiement des outils du système d’automatisation des taches ……………………......................32
C- Administration et execution de taches sur des nodes .................................………………………...45
CONCLUSION....................................................................…………………………………………..53




									RÉSUMÉ
									
									
									ABSTRACT























rocky linux history
https://rockylinux.org/fr/about

firewalld
https://access.redhat.com/documentation/fr-fr/red_hat_enterprise_linux/8/html/managing_systems_using_the_rhel_8_web_console/firewalld_managing-firewall-using-the-web-console








--------------------
Dans votre mémoire, vous pourriez analyser l'impact de Rundeck sur l'efficacité opérationnelle d'une organisation, étudier des études de cas d'intégration de Rundeck, ou même concevoir un projet pilote pour démontrer comment Rundeck peut être mis en œuvre pour résoudre des problématiques spécifiques dans un environnement informatique donné.






__WORA__ est l'acronyme de "Write Once, Run Anywhere", ce qui signifie "écrire une fois, exécuter partout". Il s'agit d'un slogan créé par Sun Microsystems pour illustrer la portabilité des applications Java.





Ces deux diagrammes semblent représenter des architectures de gestion de services informatiques, avec un focus particulier sur l'administration des systèmes et des bases de données.

1. **Première architecture:**
   - **AdminSys:** C'est probablement l'administrateur système ou le groupe d'administration.
   - **Serveur d'administration:** Ce serveur sert de point central pour la gestion des différents services en aval.
   - **Les services gérés:**
	 - **BNETD:** Pourrait représenter un service ou une application spécifique.
	 - **Deux serveurs MySQL:** Ce sont des bases de données, bd1 et bd2, qui sont gérées par le serveur d'administration.
	 - **SWAN PRO:** Un autre service ou application.
	 - **OGOSecurity:** Suggère une composante de sécurité ou un service de sécurité informatique.
	 - **ONECI:** Peut représenter une autre entité ou un service spécifique.
	 - **Orange CI:** Pourrait indiquer une branche ou un service de l'entreprise de télécommunications Orange en Côte d'Ivoire.

   Dans cette architecture, il semble que le serveur d'administration centralise la gestion de divers services ou applications, probablement en fournissant des fonctions de coordination, de déploiement, de surveillance ou de configuration.

2. **Deuxième architecture:**
   - **Rundeck:** Dans cette variante, Rundeck remplace le "serveur d'administration" du premier diagramme. Rundeck est une plateforme d'automatisation de serveurs qui aide à automatiser les tâches administratives routinières et à exécuter des scripts sur différents serveurs.
   - **Autres composants:** Ils restent identiques au premier schéma.

   Avec Rundeck au centre, cette architecture montre que l'outil est utilisé pour orchestrer et automatiser les tâches sur les différents services et serveurs. Cela pourrait inclure le déploiement de mises à jour, l'exécution de tâches d'administration de bases de données, la gestion des opérations de sécurité, et la coordination des services entre différentes branches ou entités comme BNETD, SWAN PRO, OGOSecurity, ONECI, et Orange CI.

Dans les deux cas, l'accent est mis sur la centralisation de la gestion et l'automatisation des opérations informatiques, ce qui est essentiel pour l'efficacité et la réactivité d'un système informatique d'entreprise.
